#!/usr/bin/env python
"""
For LDEO-processed ladcp data: use the standard *.mat and *.ladcp.mat (if available)
files to generate a netcdf file.  Output is similar, but not identical,
to that produced by the original ladcp2cdf.m in the LDEO software.

Differences include:

- The tim dimension variable, renamed 'time', is now float64 days since 1970-01-01.
  In the version made by ladcp2cdf.m it was a float32 Matlab datenum.
- The name and date variables have been removed.  Name remains as a global
  attributes.  The YMDHMS form of 'date' has been
  converted to an ISO string and added as a 'datetime' global attribute.
- The lon and lat variables are now scalars.
- The tim_hour array has been removed.
- Scalar variables (ubar, vbar) from the .mat file are added.
- Date errors in global attributes supplied by *.ladcp.mat are fixed.
- Attributes ctd_starttime and ctd_endtime have been converted to ISO strings.
- The file size has been halved by removing the 'Blocks received'
  lines from the data download log attribute.
- Global attributes are sorted by name.
- Vector non-coordinate array variables are sorted by name.
- A sequential version number (as a string) is added as the first global
  attribute.
- The output is CF-1.8 compliant.

"""

# NOTE: the module docstring (above) is included as the second global attribute.

from argparse import ArgumentParser

import os
from collections import OrderedDict

import netCDF4 as nc

import numpy as np

from pycurrents.system import Bunch
from pycurrents.file.matfile import loadmatbunch
from pycurrents.codas import to_day

# Increment this version number with each change to the source that makes a
# difference in the output.  The version was not included originally, so we are
# starting here with "2" to indicate that this is not the first.
version_ldeo_to_cdf = "2"

# Local dictionary with the variable attributes to be used with
# cruises for which we do not have the *.ladcp.mat files.
# Generated by loading the "att" dictionary from a recent file,
# and then converting to a string with
#
#     repr(att).replace('}', '}\n')
#
# Modified for CF compliance, etc.
# These are actually overrides, not defaults, for the case where attrs are
# coming from the .ladcp.mat file.

_default_attrs = {'zbot': {'long_name': 'Bottom Referenced Profile Depth', 'units': 'm'}
    , 'ubot': {'long_name': 'Bottom Referenced Profile U', 'units': 'm/s'}
    , 'vbot': {'long_name': 'Bottom Referenced Profile V', 'units': 'm/s'}
    , 'uerrbot': {'long_name': 'Bottom Referenced Profile Velocity Error', 'units': 'm/s'}
    , 'z_sadcp': {'long_name': 'SADCP Profile Depth', 'units': 'm'}
    , 'u_sadcp': {'long_name': 'SADCP Profile U', 'units': 'm/s'}
    , 'v_sadcp': {'long_name': 'SADCP Profile V', 'units': 'm/s'}
    , 'uerr_sadcp': {'long_name': 'SADCP Profile Velocity Error', 'units': 'm/s'}
    , 'z': {'long_name': 'Depth', 'units': 'Meters'}
    , 'u': {'long_name': 'U', 'units': 'm/s'}
    , 'v': {'long_name': 'V', 'units': 'm/s'}
    , 'uerr': {'long_name': 'Velocity Error', 'units': 'm/s'}
    , 'nvel': {'long_name': 'LADCP number of ensembles per bin', 'units': 'count'}
    , 'ubar': {'long_name': 'LADCP U Barotropic', 'units': 'm/s'}
    , 'vbar': {'long_name': 'LADCP V Barotropic', 'units': 'm/s'}
    # 'tim' is transformed into 'time' with the new units
    , 'tim': {'long_name': 'Station Time Series',
                'units': 'days since 1970-01-01 0:0:0',
                'calendar': 'standard'}
    , 'lon': {'long_name': 'Longitude', 'units': 'degrees_east'}
    , 'lat': {'long_name': 'Latitude', 'units': 'degrees_north'}
    , 'shiplon': {'long_name': 'Longitude', 'units': 'degrees_east'}
    , 'shiplat': {'long_name': 'Latitude', 'units': 'degrees_north'}
    , 'xship': {'long_name': 'Ship Position E', 'units': 'm'}
    , 'yship': {'long_name': 'Ship Position N', 'units': 'm'}
    , 'uship': {'long_name': 'Ship Velocity U', 'units': 'm/s'}
    , 'vship': {'long_name': 'Ship Velocity V', 'units': 'm/s'}
    , 'zctd': {'long_name': 'Depth of CTD', 'units': 'm'}
    , 'wctd': {'long_name': 'CTD Velocity W', 'units': 'm/s'}
    , 'uctd': {'long_name': 'CTD Velocity U', 'units': 'm/s'}
    , 'vctd': {'long_name': 'CTD Velocity V', 'units': 'm/s'}
    , 'uctderr': {'long_name': 'CTD Velocity Error', 'units': 'm/s'}
    , 'xctd': {'long_name': 'CTD Position Relative to Start E', 'units': 'm'}
    , 'yctd': {'long_name': 'CTD Position Relative to Start N', 'units': 'm'}
    , 'range': {'long_name': 'ADCP total range of data', 'units': 'm'}
    , 'range_do': {'long_name': 'ADCP down looking range of data', 'units': 'm'}
    , 'range_up': {'long_name': 'ADCP up looking range of data', 'units': 'm'}
    , 'ts': {'long_name': 'ADCP echo amplitude profile bin 1', 'units': 'dB'}
    , 'ts_out': {'long_name': 'ADCP echo amplitude profile last down bin', 'units': 'dB'}
    , 'u_do': {'long_name': 'LADCP down only profile U', 'units': 'm/s'}
    , 'v_do': {'long_name': 'LADCP down only profile V', 'units': 'm/s'}
    , 'u_up': {'long_name': 'LADCP up only profile U', 'units': 'm/s'}
    , 'v_up': {'long_name': 'LADCP up only profile V', 'units': 'm/s'}
    , 'p': {'long_name': 'Pressure', 'units': 'dBar'}
    , 'ensemble_vel_err': {'long_name': 'ADCP ensemble velocity error', 'units': 'm/s'}
    , 'u_shear_method': {'long_name': 'LADCP shear method profile U', 'units': 'm/s'}
    , 'v_shear_method': {'long_name': 'LADCP shear method profile V', 'units': 'm/s'}
    , 'w_shear_method': {'long_name': 'LADCP shear method profile W', 'units': 'm/s'}
    , 'ctd_t': {'long_name': 'CTD profile temperature', 'units': 'Degree C'}
    , 'ctd_s': {'long_name': 'CTD profile salinity', 'units': 'psu'}
    , 'ctd_ss': {'long_name': 'CTD profile sound speed', 'units': 'm/s'}
    , 'ctd_N2': {'long_name': 'CTD profile stability', 'units': '1/s^2'}
    }

# I thought that more dimensions might be translated, but ended up with only 1:
newdim_dict = dict(tim="time")
olddim_dict = dict(time="tim")

# The present matlab nc files are not using missing_value
def load_matfiles(fbase, masked=False):
    """
    Combine the contents of *.mat and *.ladcp.mat in a single Bunch.
    If *.ladcp.mat is not available, return just the contents of *.mat.
    This is appropriate for data from Andreas starting March 29, 2017.

    """
    fmat = fbase + '.mat'
    fladcpmat = fbase + '.ladcp.mat'
    flist = []
    if os.path.exists(fladcpmat):
        flist.append(fladcpmat)
    if os.path.exists(fmat):
        flist.append(fmat)
    else:
        raise RuntimeError('file %s was not found' % fmat)

    lmat = Bunch()
    for fname in flist:
        lmat.update(loadmatbunch(fname, masked=masked))

    if 'att' not in lmat:
        lmat.att = _default_attrs
    return lmat

def _split_lmat(lmat):
    """
    The array variables are in the "dr" structure; their attributes
    are in "att" will be returned as "var_attrs; combine the global
    attribute variables from the remaining structures into "attrs".
    """
    dr = lmat.dr
    var_attrs = lmat.att
    var_attrs.update(_default_attrs)  ## "default" takes precedence...
    attrs = Bunch()
    for name, b in lmat.items():
        if name in ['dr', 'att']:
            continue
        attrs.update(b)
    return dr, var_attrs, attrs

def _to_nc(varname, x):
    """
    Non-dimension array variables are stored as float32, with
    the exception of "nvel", which comes in as uint8 and has to
    be converted to int16.
    """
    if varname == 'nvel':
        xnc = x.astype(np.int16)
    else:
        xnc = x.astype(np.float32)
    return xnc

def _fix_type(x):
    """
    Fixup for attributes: netcdf3 doesn't accept unsigned ints.
    This is also used for scalar variables.
    """
    if isinstance(x, str):
        return x   #  OK only for attributes

    if not hasattr(x, 'dtype'):
        if isinstance(x, int):
            return np.int32(x)
        if isinstance(x, float):
            return np.float64(x)

    if x.dtype == np.uint8:
        return x.astype(np.int16)
    elif x.dtype == np.uint16:
        return x.astype(np.int32)
    elif x.dtype.kind == 'U':
        return '\n'.join([str(s) for s in x])
    return x

def _filter_attr(item):
    """
    Remove huge list of "Blocks received" lines.
    This is an improvement over the matlab version.
    """
    name, val = item
    if "_rawlog" not in name:
        return item
    lines = [line.rstrip() for line in val.split('\n')
             if not "Blocks received" in line]
    return name, '\n'.join(lines)

def _to_sorted_dict(d):
    """
    Convert a dict to a sorted OrderedDict, while filtering and fixing.
    The first entry will be the version of this file, and the second will be
    the docstring of this module.
    """
    out = OrderedDict()
    out["version_ldeo_to_cdf"] = version_ldeo_to_cdf
    out["description_ldeo_to_cdf"] = __doc__
    for item in sorted(d.items()):
        # Entries like 'saveplot' are useless and can contain a 2-D empty
        # array, which is not valid as an attribute.
        if item[0].startswith('save'):
            continue
        item = _filter_attr(item)
        try:
            item = (item[0], _fix_type(item[1]))
        except AttributeError:
            pass
        out[item[0]] = item[1]
    return out

def _to_cdf(fname, lmat):
    """
    Write the nc file...
    """
    dr, var_attrs, attrs = _split_lmat(lmat)

    d = nc.Dataset(fname, mode='w', format='NETCDF3_CLASSIC')

    attrs["Conventions"] = "CF-1.8"

    # Fix 2 times.
    for key in ("ctd_starttime", "ctd_endtime"):
        unixdays = attrs[key] - 2440588
        attrs[key] = str(np.int64(unixdays * 86400).astype("datetime64[s]"))

    dt64 = np.datetime64("%04d-%02d-%02dT%02d:%02d:%02d" % tuple(dr["date"]), "s")
    attrs["datetime"] = str(dt64)

    # Add all of the global attributes.
    d.setncatts(_to_sorted_dict(attrs))

    # name is already an attribute, and tim_hour is useless.
    # We added an attribute for the contents of "date"
    for name in ("date name tim_hour".split()):
        del dr[name]

    dimsizes = []
    array_dimnames = ('zbot', 'tim', 'z', 'z_sadcp')
    new_array_dimnames = ('zbot', 'time', 'z', 'z_sadcp')
    for key in array_dimnames:
        if key in dr:
            newkey = newdim_dict.get(key, key)
            dimsizes.append((newkey, len(dr[key])))

    for name, size in dimsizes:
        d.createDimension(name, size)

    for key in array_dimnames:  # oldnames
        if key in dr:
            if key == 'tim':
                d.createVariable('time', "f8", ('time',))
                # ladcp2cdf.m botches this by using float32; the
                # result with Matlab is very odd--many *most* signif.
                # digits seem to have been lost.  To top it off,
                # the "Julian day" time used here is the *standard*
                # Julian day time *plus* 12 hours!
                unixdays = dr['tim'] - 2440588
                d.variables['time'][:] = unixdays
            else:
                newkey = newdim_dict.get(key, key)
                d.createVariable(newkey, "f4", (newkey,))
                d.variables[newkey][:] = dr[key]

    dimnames = list(d.dimensions.keys())  # New dimnames.

    # Add attributes for the dimension variables.
    for name in dimnames:
        oldname = olddim_dict.get(name, name)
        if oldname in var_attrs:
            d.variables[name].setncatts(var_attrs[oldname])

    # Add the non-dimension array variables with their attributes.
    old_dimnames = [olddim_dict.get(name, name) for name in dimnames]
    varnames = [name for name in dr.keys() if name not in old_dimnames]
    varnames.sort()

    # Scalars from arrays:
    for varname in ("lon", "lat"):
        var = d.createVariable(varname, float)
        var.setncatts(_default_attrs[varname])
        var[:] = dr[varname]
        varnames.remove(varname)

    for varname in varnames:
        x = dr[varname]
        try:
            n = len(x)
        except TypeError:
            # scalar; omitted by ladcp2cdf, but we will save them.
            xnc = _fix_type(x)
            var = d.createVariable(varname, xnc.dtype)
            var[:] = xnc
        else:
            xnc = _to_nc(varname, x)

            for dname in new_array_dimnames:
                try:
                    dvar = d.variables[dname]
                except KeyError:
                    continue
                # Hack from ladcp2cdf.m: assume no two dimensions are
                # the same, so the dimension is found by matching the
                # variable size to the dimension size.
                if len(dvar) == n:
                    var = d.createVariable(varname, xnc.dtype, (dname,))
                    var[:] = xnc
                    break

        if varname in var_attrs:
            var.setncatts(var_attrs[varname])
    d.close()

def _fixup_attributes(lmat):
    """
    In-place correction of global decimal_day attributes.
    """
    dd_names = [n for n in lmat.da if 'decimal_day' in n]
    dday_ref = to_day(lmat.dr.date[0], lmat.dr.date)
    dday_int, dday_frac = divmod(dday_ref, 1)
    for name in dd_names:
        d_int, d_frac = divmod(lmat.da[name], 1)
        delta = round(dday_frac - d_frac)
        lmat.da[name] = dday_int + d_frac + delta

def convert(matname, outdir=None):
    """
    Write a netcdf file based on two .mat files from LDEO.

    *matname* is the name of the .mat file *without* the '.ladcp.' part.
    """
    fbase = os.path.splitext(matname)[0]
    outname = fbase + ".nc"
    if outdir is not None:
        outname = os.path.join(outdir, os.path.basename(outname))
    lmat = load_matfiles(fbase)
    if 'da' in lmat:  # only present if we have *.ladcp.mat files
        _fixup_attributes(lmat)
    _to_cdf(outname, lmat)


if __name__ == "__main__":
    parser = ArgumentParser(
        description="Generate comprehensive netcdf3 files from LDEO matfiles"
    )
    parser.add_argument('--outdir',
                        help='directory in which to write the nc files')
    parser.add_argument('matnames', nargs='+', metavar='MATFILE',
                        help=('LDEO matfile to convert '
                        '(without ".ladcp."; ".mat" is optional)'))
    args = parser.parse_args()

    for matname in args.matnames:
        convert(matname, args.outdir)

